* Overview
This repo is intended for researching embedded rust - development environment, runtime creation, etc.
* Structure
+ This file is the repo's infodump and todo list.
+ =lib/= - in the future, library crates will go here.
+ =<crate_name>= - crate that produces a program.
+ =flake.nix= - defines development environment, packages (built with =nix build .#name=), and more (in the future).
* Crates
** =AT32F403ACGU7_experiment=
+ Study of runtime creation on the aforementioned chip.
+ Test crate for developing flake's features.
* Chips
** Main characteristics
| Chip          | Core(s)       | Freq.   | SRAM | ROM/Flash  | Interfaces                                    | Timers |
|---------------+---------------+---------+------+------------+-----------------------------------------------+--------|
| AT32F403ACGU7 | Cortex M4F    | 240MHz  | 224K | 1M         | 3 I2C, 8 USART, 4 SPI, 2 CAN, 2 SD            |     17 |
|---------------+---------------+---------+------+------------+-----------------------------------------------+--------|
| STM32F411CEU6 | Cortex M4F    | 100MHz  | 512K | 128K       | 3 I2C, 3 USART, 5 SPI, 1 SD                   |     11 |
|---------------+---------------+---------+------+------------+-----------------------------------------------+--------|
| RP2040        | 2x Cortex M0+ | 133+MHz | 264K | 2M-16M     | 2 I2C, 2 UART, 2 SPI, PIO                     |     5+ |
|---------------+---------------+---------+------+------------+-----------------------------------------------+--------|
| ESP32-C3FH4   | RV32IMC       | 160MHz  | 400K | 384K/4MB   | 1 I2C, 2 UART, 3 SPI, 1 I2S, 1 RMT, BLE, WiFi |      2 |
|---------------+---------------+---------+------+------------+-----------------------------------------------+--------|
| CH592F        | RV32IMAC      | 80MHz   | 26K  | 512K total | 1 I2C, 4 UART, 1 SPI, BLE                     |      4 |
** Secondary characteristics
+ TODO: properly count PWM channels on at32 and stm32
+ Low power draw - typical current drawn while in the deepest sleep mode possible (Standby for M4F based chips, for example)
  + First number - without RTC
  + Second number - with RTC

| Chip          | Extra boot modes | PWM | DMA | MPU   | RTC backed memory  | Low power draw    | USB endpoints     |
|---------------+------------------+-----+-----+-------+--------------------+-------------------+-------------------|
| AT32F403ACGU7 | Flash bank 2     |  13 |  14 | 8*8   | 84 bytes           | 3.9 uA / 4.6 uA   | 8 bi              |
|---------------+------------------+-----+-----+-------+--------------------+-------------------+-------------------|
| STM32F411CEU6 | None             | 22? |  16 | 8*8   | 80 bytes           | 1.8 uA / 2.4 uA ‚Åã | 1 bi, 3 IN, 3 OUT |
|---------------+------------------+-----+-----+-------+--------------------+-------------------+-------------------|
| RP2040        | SPI              |  16 |  12 | 8*8 ‚Ä† | None?              | 180 uA / 181 uA ¬ß | 16 bi             |
|---------------+------------------+-----+-----+-------+--------------------+-------------------+-------------------|
| ESP32-C3FH4   | None             |   6 | 3/3 | None  | 8K SRAM + 32 bytes | 1 uA / 5 uA       | 3 IN, 2 OUT       |
|---------------+------------------+-----+-----+-------+--------------------+-------------------+-------------------|
| CH592F        | None             | 12? |     | None  | 2K SRAM + 24K SRAM | 0.8 uA / 7.3 uA ‚ôÇ | 8 bi              |

+ ‚Ä† - subregions are equal in size
+ ‚Åã - Subtract 1.2 uA if power-down reset is disabled (per datasheet)
+ ¬ß - RTC is assumed to be consuming 1.1 uA
+ ‚ôÇÔ∏é - Numbers given for sleep mode, lowest and highest possible configurations
  + Shutdown mode (reset on wakeup) consumes 0.4 uA / 1 uA
** Specific traits
*** Artery AT32F403A
+ SRAM is split into 96K and 128K (according to datasheet)
  - Seems to be insignificant, as they are placed right next to each other in the memory map.
+ Flash memory is split into two 512K banks, the chip can be configured to boot from either of them.
  + They are placed right next to each other in the memory map, so they can be treated as one.
+ Configurable code/data readout protection (sLib)
  + Code and data sections are separate
  + Configurable region size
  + When active, protected regions are unaffected by mass erase
  + Deactivation is passcode protected (which is configured during activation)
  + Deactivation necessarily does mass erase, including on previously protected regions.
+ TODO: research external memory controller (XMC)
+ CRC
*** STMicroelectronics STM32F411xC/xE
+ Readout protection
  1. Level 1 allows downgrading to level 0 (triggering mass erase) and forbids read/write over serial
     - Insecure, has two methods of attacking, resulting in dumping the entire flash.
  2. Level 2 disables bootloader and debugging; only the chip's program can make changes to it; *irreversible*
     + Attack requires flipping bits in the flash, which requires destroying chip's top.
+ CRC
*** Raspberry Pi RP2040
+ UF2 loader allows drag-n-drop flashing
+ Alongside with UF2 loader, PICOBOOT interface is also available
+ Can eke out 20K more SRAM if not using XIP caching and USB
+ Can be overclocked to more than 240MHz and overvolted to 1.3V
+ Has unique Programmable IO (PIO) peripheral, which is essentially a hardware for bit-banging at high speeds
  + Example: [[https://github.com/Wren6991/PicoDVI][Bit banged DVI]], [[https://github.com/kingyoPiyo/Pico-10BASE-T][Bit banged Ethernet]]
  + TODO: Should be described in its own section
+ Bus performance counters for profiling
+ Debug access provides access to one of the cores or Rescue debug port
  + Can be seen with =swdp_scan=
  + Useful when cores cannot be used (due to halted system clock).
  + Rescue DP hard resets the chip and sets a flag about rescue reset, which bootrom checks for, clears and halts the cores.
+ Resus mechanism can recover the controller from halted system clock.
+ Bit banding for peripherals' registers
+ Single-cycle IO (SIO) is connected to both processors and provides 1 cycle access to included peripherals at the cost of not having bit banding.
  Included:
  1. CPUID (unique to each core)
  2. FIFO lines between cores (two for both directions)
  3. 32 hardware spinlocks (shared between cores)
  4. GPIO (shared)
  5. Interpolators (can be used to compute some functions)
     + Can also lerp üê∏
     + Can also clamp
+ 8 cycle integer divider (will need to support separately)
+ Writes to memory-mapped IO registers are always 32 bit sized, if data being written to it is smaller than required it will be duplicated to fill the space.
+ DMA operates faster than processors, doing reads and writes simualteniously
  + TODO: check if this is the case for other controllers, datasheets for them does not explicitly state this.
+ DMA can do CRC for free
*** Espressif ESP32-C3FH4
+ Flash encryption
+ Secure/Insecure environment split
+ 4K one-time-write memory (eFuse)
  - but only 1792 bits available?
+ 8K of RTC-powered memory
+ Remote control (infrared)
+ TWAI (meant for automotive)
+ Hardware acceleration of SHA/RSA/AES/etc.
*** WCH CH592F
+ Flash is divived as such:
  1. 448K General
  2. 32K Data
  3. 24K Bootloader
  4. 8K Info
+ Can run at clock as low as 32KHz
+ RAM is split into 2K and 24K, which are powered separately.
  It is therefore possible to disable 24K RAM to conserve power
+ Capacitive touch input support
+ Hardware acceleration for AES
* TODO Boards
+ TODO: describe the microcontroller boards that I currently have
* Documentation
** Artery
*** [[https://www.arterychip.com/download/DS/DS_AT32F403A_V2.04_EN.pdf][AT32F403A Datasheet]]
*** [[https://arterychip.com/download/RM/RM_AT32F403A_407_EN_V2.05.pdf][AT32F403A/407 Reference manual]]
** STMicroelectronics
*** [[https://www.st.com/resource/en/datasheet/stm32f411ce.pdf][ST32F411xC/E Datasheet]]
*** [[https://www.st.com/resource/en/reference_manual/DM00119316-.pdf][STM32F411xC/E Reference manual]]
*** [[https://www.st.com/resource/en/programming_manual/pm0214-stm32-cortexm4-mcus-and-mpus-programming-manual-stmicroelectronics.pdf][STM32 Cortex-M4F Programming manual]]
** Raspberry Pi
*** [[https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf][RP2040 Datasheet]]
** Espressif
*** [[https://www.espressif.com/sites/default/files/documentation/esp32-c3_datasheet_en.pdf][ESP32-C3 Datasheet]]
*** [[https://www.espressif.com/sites/default/files/documentation/esp32-c3_technical_reference_manual_en.pdf#usbserialjtag][ESP32-C3 Technical reference manual]]
*** [[https://docs.espressif.com/projects/esp-idf/en/latest/esp32c3/index.html][ESP-IDF Programming guide]]
** WCH
* Notes
** Flashing/debugging
*** STM32 Debug probe
+ Looked at Black Magic Debug (standalone version) (=blackmagic= in nixpkgs)
+ Converted STM32 blackpill into Black Magic Probe
  1. Provided shell could be updated
     1. Add meson and ninja
  2. Instruction on building the probe for blackpills could be updated
     1. There is no ~blackpill-f4x1cx.ini~
  3. Need to heat up blackpill for dfu to work
  4. blackpill will *not* properly reboot on RST+BOOT0
     One needs to hold BOOT0 while attaching USB cable
     [[https://www.stm32duino.com/viewtopic.php?t=1234&start=20][Source]]
  5. Built image does not work
  6. Downloaded a ~.zip~ mentioned [[https://github.com/blackmagic-debug/blackmagic/issues/1454][here]]
     This worked! It is detected properly now
*** Using GDB with debug probe
1. Attach the debugged MCU to the probe using proper pins (written in BMP's readme)
2. In GDB, =target extended-remote /dev/ttyACM0= (I assume I also need to run it as root or get permissions)
3. Do =monitor swdp_scan= to verify
4. [[https://black-magic.org/usage/gdb-commands.html][Follow this]]
*** probe-rs
+ Looked into =probe-rs=
  + Allows using stlink/CMSIS-DAP/jlink probes
- Fails to work with my probe
  Error message: ~An error with the usage of the probe occurred~
*** AT32
+ Checked out =dfu-util=
  - AT32 can be dumped but not flashed
+ Built [[https://github.com/Encryptize/openocd-at32][forked openocd]] but did not include it properly in the env
  - Could not make it work
+ Built [[https://github.com/ArteryTek/openocd][arterytek's fork of openocd]] but did not include it properly in the env
  - Could not make it work
+ Need to find options for flashing with or without debug probe
** MCU differences
Differences can exist between boards of same markings.
That is, they can be of different revisions.
For example, rp2040 revisions fix some erratas, while stm32 blackpill replaced XTAL with a slower one.
** Black Magic Probe
+ Can be created by flashing the firmware on the STM32
  - STM32F411 may however be insufficient for full use, check github issues
+ Makes it easy to debug using GDB
+ GDB can also flash firmware
** Automating development
+ GDB can be used to automate flashing
  See [[https://black-magic.org/usage/gdb-automation.html][this]]
+ blackmagic can be built as hosted (check the website) to use a probe to flash/read/etc. without GDB
  Currently not investigated
** Cargo
+ Needs to include
  #+begin_src toml
    cargo-features = ["per-package-target"]
    [package]
    forced-target = "thumbv7em-none-eabihf"
  #+end_src
  in order for the target to be built properly. Otherwise, if =cargo build= is ran from workspace directory,
  target setting in =.cargo/config.toml= will be ignored.
** Nix environment
+ Does not use nixpkgs' =systemCross=.
+ =rust-overlay= is used to get the toolchain from the file
+ =crane= is used to build packages.
  + =doCheck= has to be false because embedded rust cannot be properly tested
  + Source clearing uses crane's filter with a filter for linker scripts
+ =nix run= could be used to flash/debug
  Necessary flake outputs should be created
+ if cargo behaves as if target was not installed, developer should reenter the env
  1) =direnv reload= if using default shell
  2) Exit and enter the shell
+ Development environment could be split into one-arch-only and all-arches
  This would be good for developers that only intend to work on one arch.
* Tasks
** openocd fork
+ TODO: properly include arterytek's openocd fork into the env
  This will let me debug AT32 using that, if I want it
+ TODO: include =openocd.cfg= from =github:rust-embedded/cortex-m-quickstart=
** Running
+ TODO: consider using make or similar to run with debugger/black magic/qemu/etc.
** CURRENT Flake
+ TODO: Make =nix run= be able to drop user into gdb, flash or verify the program
  - I am currently trying the approach that does not work with rp2040, so I need to develop a different one
    1. I am verifying that I am flashing the correct device by doing =monitor swdp_scan= and cutting the target info from the last line.
       This assumes that there is only one target. However, rp2040 has three, two cores and a dummy that is used to reset the chip.
    2. I could have multiple scripts in the repo for different chips.
+ TODO: testing can just run =cargo check=
+ TODO: formatting, clippy, etc. - could they be done through nix?
** NEXT Document boards that I currently have
